
import { doc, getDoc, setDoc, updateDoc, collection, getDocs, where, query, deleteDoc, writeBatch } from "firebase/firestore"; 
import { db, auth } from "@/lib/firebase";
import type { User } from 'firebase/auth';

export interface UserData {
  displayName: string;
  email: string;
  userType: 'motorista' | 'cliente' | 'admin';
  cpf?: string;
  cnpj?: string;
  cnh?: string;
  phone?: string;
  companyName?: string;
  isOnline?: boolean;
  isActive?: boolean; // Flag para indicar se a conta est√° ativa
  tempPassword?: string; // Senha tempor√°ria para usu√°rios criados pelo admin
  needsAuthSetup?: boolean; // Flag para indicar que precisa configurar autentica√ß√£o
  createdAt?: Date; // Data de cria√ß√£o do usu√°rio
  updatedAt?: Date; // Data da √∫ltima atualiza√ß√£o
}

/**
 * Cria um documento do usu√°rio no Firestore durante o cadastro.
 * @param userId - O ID do usu√°rio.
 * @param userData - Os dados iniciais do usu√°rio.
 */
export const createUserDocument = async (userId: string, userData: Partial<UserData>) => {
  try {
    const userRef = doc(db, "users", userId);
    await setDoc(userRef, userData);
  } catch (error) {
    console.error("Erro ao criar documento do usu√°rio: ", error);
    throw error;
  }
};

/**
 * Salva os dados do usu√°rio no Firestore.
 * @param userId - O ID do usu√°rio.
 * @param userData - Os dados do usu√°rio a serem salvos.
 */
export const saveUserData = async (userId: string, userData: UserData) => {
  try {
    const userRef = doc(db, "users", userId);
    await setDoc(userRef, userData);
  } catch (error) {
    console.error("Erro ao salvar dados do usu√°rio: ", error);
    throw error;
  }
};

/**
 * Busca os dados de um usu√°rio no Firestore.
 * @param userId - O ID do usu√°rio.
 * @returns Os dados do usu√°rio ou null se n√£o encontrado.
 */
export const getUserDocument = async (userId: string): Promise<UserData | null> => {
    try {
        const userRef = doc(db, "users", userId);
        const docSnap = await getDoc(userRef);

        if (docSnap.exists()) {
            return docSnap.data() as UserData;
        } else {
            console.log("Nenhum documento encontrado para este usu√°rio!");
            return null;
        }
    } catch (error) {
        console.error("Erro ao buscar documento do usu√°rio:", error);
        throw error;
    }
};

/**
 * Cria dados b√°sicos para um usu√°rio que n√£o possui documento no Firestore.
 * @param userId - O ID do usu√°rio.
 * @param userType - O tipo do usu√°rio.
 * @param displayName - Nome do usu√°rio.
 * @param email - Email do usu√°rio.
 */
export const createBasicUserData = async (
    userId: string, 
    userType: 'motorista' | 'cliente' | 'admin',
    displayName: string,
    email: string
): Promise<UserData> => {
    try {
        console.log(`üîÑ Criando dados b√°sicos para usu√°rio ${userId} (${userType})`);
        
        const basicUserData: UserData = {
            displayName,
            email,
            userType,
            isOnline: false,
            isActive: true,
            createdAt: new Date(),
            updatedAt: new Date()
        };
        
        await createUserDocument(userId, basicUserData);
        console.log(`‚úÖ Dados b√°sicos criados para usu√°rio ${userId}`);
        
        return basicUserData;
    } catch (error) {
        console.error("‚ùå Erro ao criar dados b√°sicos do usu√°rio:", error);
        throw error;
    }
};

/**
 * Atualiza os dados de um usu√°rio no Firestore.
 * @param user - O objeto do usu√°rio do Firebase Auth.
 * @param data - Os dados a serem atualizados.
 */
export const updateUserProfile = async (user: User, data: Partial<UserData>) => {
    if (!user) {
      throw new Error("Usu√°rio n√£o autenticado.");
    }
  
    try {
      const userRef = doc(db, 'users', user.uid);
      await updateDoc(userRef, data);
    } catch (error) {
      console.error('Erro ao atualizar o perfil do usu√°rio:', error);
      throw error;
    }
};

/**
 * Atualiza os dados de um usu√°rio no Firestore (alias para compatibilidade).
 * @param user - O objeto do usu√°rio do Firebase Auth.
 * @param data - Os dados a serem atualizados.
 */
export const updateUserDocument = updateUserProfile;

/**
 * Busca todos os motoristas cadastrados.
 * @returns Uma lista de motoristas.
 */
export const getDrivers = async (): Promise<(UserData & { uid: string })[]> => {
    try {
        const q = query(collection(db, "users"), where("userType", "==", "motorista"));
        const querySnapshot = await getDocs(q);
        const drivers = querySnapshot.docs.map(doc => ({
            uid: doc.id,
            ...doc.data()
        })) as (UserData & { uid: string })[];
        return drivers;
    } catch (error) {
        console.error("Erro ao buscar motoristas:", error);
        throw error;
    }
}

/**
 * Busca apenas motoristas online.
 * @returns Uma lista de motoristas online.
 */
export const getOnlineDrivers = async (): Promise<(UserData & { uid: string })[]> => {
    try {
        console.log("üîç Buscando motoristas online...");
        
        // Buscar todos os usu√°rios
        const allUsersQuery = query(collection(db, "users"));
        const allUsersSnapshot = await getDocs(allUsersQuery);
        
        console.log(`üìä Total de usu√°rios encontrados: ${allUsersSnapshot.size}`);
        
        // Filtrar apenas motoristas online
        const allUsers = allUsersSnapshot.docs.map(doc => ({
            uid: doc.id,
            ...doc.data()
        })) as (UserData & { uid: string })[];
        
        console.log("üîç Todos os usu√°rios encontrados:", allUsers.map(user => ({
            uid: user.uid,
            displayName: user.displayName,
            userType: user.userType,
            isOnline: user.isOnline
        })));
        
        // Filtrar motoristas
        const motoristas = allUsers.filter(user => user.userType === 'motorista');
        console.log(`üöõ Total de motoristas encontrados: ${motoristas.length}`);
        console.log("üîç Motoristas:", motoristas.map(driver => ({
            uid: driver.uid,
            displayName: driver.displayName,
            isOnline: driver.isOnline
        })));
        
        // Filtrar apenas motoristas online
        const onlineDrivers = motoristas.filter(user => user.isOnline === true);
        
        console.log(`‚úÖ Motoristas online encontrados: ${onlineDrivers.length}`);
        console.log("üîç Motoristas online:", onlineDrivers.map(driver => ({
            uid: driver.uid,
            displayName: driver.displayName,
            isOnline: driver.isOnline
        })));
        
        return onlineDrivers;
    } catch (error) {
        console.error("‚ùå Erro ao buscar motoristas online:", error);
        console.log("‚ö†Ô∏è Erro detectado, retornando lista vazia");
        return [];
    }
}



/**
 * Atualiza o status online/offline de um motorista.
 * @param userId - ID do usu√°rio
 * @param isOnline - Status online (true) ou offline (false)
 */
export const updateDriverStatus = async (userId: string, isOnline: boolean): Promise<void> => {
    try {
        const userRef = doc(db, "users", userId);
        await updateDoc(userRef, { isOnline });
        console.log(`Status do motorista ${userId} atualizado para: ${isOnline ? 'online' : 'offline'}`);
        
        // Verificar se foi salvo corretamente
        const updatedDoc = await getDoc(userRef);
        if (updatedDoc.exists()) {
            const data = updatedDoc.data();
            console.log(`‚úÖ Verifica√ß√£o: Status salvo no Firebase:`, {
                userId,
                isOnline: data.isOnline,
                userType: data.userType,
                displayName: data.displayName
            });
        }
    } catch (error) {
        console.error("Erro ao atualizar status do motorista:", error);
        throw error;
    }
}

/**
 * Inicializa o campo isOnline para usu√°rios que n√£o possuem este campo.
 * Esta fun√ß√£o deve ser executada apenas por administradores.
 */
export const initializeIsOnlineField = async (): Promise<void> => {
    try {
        console.log("üîÑ Inicializando campo isOnline para usu√°rios existentes...");
        
        // Buscar todos os usu√°rios
        const usersQuery = query(collection(db, "users"));
        const usersSnapshot = await getDocs(usersQuery);
        
        const batch = writeBatch(db);
        let updateCount = 0;
        
        usersSnapshot.docs.forEach(doc => {
            const data = doc.data();
            
            // Se o campo isOnline n√£o existir, inicializar como false
            if (data.isOnline === undefined) {
                batch.update(doc.ref, { isOnline: false });
                updateCount++;
                console.log(`üìù Marcado para atualiza√ß√£o: ${doc.id} (${data.userType})`);
            }
        });
        
        if (updateCount > 0) {
            await batch.commit();
            console.log(`‚úÖ Campo isOnline inicializado para ${updateCount} usu√°rios`);
        } else {
            console.log("‚ÑπÔ∏è Todos os usu√°rios j√° possuem o campo isOnline");
        }
        
    } catch (error) {
        console.error("‚ùå Erro ao inicializar campo isOnline:", error);
        throw error;
    }
}

/**
 * Salva as anota√ß√µes de um usu√°rio no Firestore.
 * @param userId - O ID do usu√°rio.
 * @param notes - As anota√ß√µes a serem salvas.
 */
export const saveUserNotes = async (userId: string, notes: string): Promise<void> => {
    try {
        const userRef = doc(db, "users", userId);
        await updateDoc(userRef, { notes: notes });
    } catch (error) {
        // Se o documento n√£o existir, podemos cri√°-lo com as notas
        if ((error as any).code === 'not-found') {
            const userRef = doc(db, "users", userId);
            await setDoc(userRef, { notes: notes }, { merge: true });
        } else {
            console.error("Erro ao salvar anota√ß√µes do usu√°rio:", error);
            throw error;
        }
    }
};

/**
 * Busca as anota√ß√µes de um usu√°rio no Firestore.
 * @param userId - O ID do usu√°rio.
 * @returns As anota√ß√µes do usu√°rio ou uma string vazia se n√£o houver.
 */
export const getUserNotes = async (userId: string): Promise<string> => {
    try {
        const userRef = doc(db, "users", userId);
        const docSnap = await getDoc(userRef);
        if (docSnap.exists() && docSnap.data().notes) {
            return docSnap.data().notes;
        }
        return "";
    } catch (error) {
        console.error("Erro ao buscar anota√ß√µes do usu√°rio:", error);
        return ""; // Retorna string vazia em caso de erro
    }
};

/**
 * Remove todos os dados de um usu√°rio do Firestore.
 * Esta fun√ß√£o deve ser chamada ANTES de excluir a conta do Firebase Auth.
 * @param userId - O ID do usu√°rio.
 * @param userType - O tipo do usu√°rio (motorista, cliente ou admin).
 */
export const deleteUserData = async (userId: string, userType: 'motorista' | 'cliente' | 'admin'): Promise<void> => {
    try {
        console.log(`üóëÔ∏è Iniciando exclus√£o de dados para usu√°rio ${userId} (${userType})`);
        
        const batch = writeBatch(db);
        let deletedCount = 0;

        // 1. Excluir dados do usu√°rio
        try {
            const userRef = doc(db, "users", userId);
            batch.delete(userRef);
            deletedCount++;
            console.log(`‚úÖ Marcado para exclus√£o: documento do usu√°rio`);
        } catch (error) {
            console.warn("‚ö†Ô∏è Erro ao marcar usu√°rio para exclus√£o:", error);
        }

        // 2. Excluir transa√ß√µes do usu√°rio
        try {
            const transactionsQuery = query(collection(db, "transactions"), where("userId", "==", userId));
            const transactionsSnapshot = await getDocs(transactionsQuery);
            transactionsSnapshot.forEach((doc) => {
                batch.delete(doc.ref);
                deletedCount++;
            });
            console.log(`‚úÖ Marcado para exclus√£o: ${transactionsSnapshot.size} transa√ß√µes`);
        } catch (error) {
            console.warn("‚ö†Ô∏è Erro ao buscar transa√ß√µes:", error);
        }

        // 3. Excluir agendamentos (se for cliente)
        if (userType === 'cliente') {
            try {
                const appointmentsQuery = query(collection(db, "appointments"), where("clientId", "==", userId));
                const appointmentsSnapshot = await getDocs(appointmentsQuery);
                appointmentsSnapshot.forEach((doc) => {
                    batch.delete(doc.ref);
                    deletedCount++;
                });
                console.log(`‚úÖ Marcado para exclus√£o: ${appointmentsSnapshot.size} agendamentos`);
            } catch (error) {
                console.warn("‚ö†Ô∏è Erro ao buscar agendamentos:", error);
            }
        }

        // 4. Excluir jornadas de trabalho (se for motorista)
        if (userType === 'motorista') {
            try {
                const shiftsQuery = query(collection(db, "workShifts"), where("userId", "==", userId));
                const shiftsSnapshot = await getDocs(shiftsQuery);
                shiftsSnapshot.forEach((doc) => {
                    batch.delete(doc.ref);
                    deletedCount++;
                });
                console.log(`‚úÖ Marcado para exclus√£o: ${shiftsSnapshot.size} jornadas de trabalho`);
            } catch (error) {
                console.warn("‚ö†Ô∏è Erro ao buscar jornadas:", error);
            }

            // 5. Excluir dados de ve√≠culos (se for motorista)
            try {
                const vehiclesQuery = query(collection(db, "vehicles"), where("userId", "==", userId));
                const vehiclesSnapshot = await getDocs(vehiclesQuery);
                vehiclesSnapshot.forEach((doc) => {
                    batch.delete(doc.ref);
                    deletedCount++;
                });
                console.log(`‚úÖ Marcado para exclus√£o: ${vehiclesSnapshot.size} ve√≠culos`);
            } catch (error) {
                console.warn("‚ö†Ô∏è Erro ao buscar ve√≠culos:", error);
            }
        }

        // 6. Excluir notifica√ß√µes do usu√°rio
        try {
            const notificationsQuery = query(collection(db, "notifications"), where("userId", "==", userId));
            const notificationsSnapshot = await getDocs(notificationsQuery);
            notificationsSnapshot.forEach((doc) => {
                batch.delete(doc.ref);
                deletedCount++;
            });
            console.log(`‚úÖ Marcado para exclus√£o: ${notificationsSnapshot.size} notifica√ß√µes`);
        } catch (error) {
            console.warn("‚ö†Ô∏è Erro ao buscar notifica√ß√µes:", error);
        }

        // 7. Excluir configura√ß√µes de notifica√ß√£o
        try {
            const notificationSettingsQuery = query(collection(db, "notificationSettings"), where("userId", "==", userId));
            const notificationSettingsSnapshot = await getDocs(notificationSettingsQuery);
            notificationSettingsSnapshot.forEach((doc) => {
                batch.delete(doc.ref);
                deletedCount++;
            });
            console.log(`‚úÖ Marcado para exclus√£o: ${notificationSettingsSnapshot.size} configura√ß√µes de notifica√ß√£o`);
        } catch (error) {
            console.warn("‚ö†Ô∏è Erro ao buscar configura√ß√µes de notifica√ß√£o:", error);
        }

        // Executar todas as exclus√µes em lote
        if (deletedCount > 0) {
            try {
                await batch.commit();
                console.log(`‚úÖ Exclus√£o conclu√≠da: ${deletedCount} documentos removidos`);
            } catch (error) {
                console.error("‚ùå Erro ao executar batch de exclus√£o:", error);
                throw new Error("N√£o foi poss√≠vel excluir todos os dados do usu√°rio. Tente novamente.");
            }
        } else {
            console.log(`‚ÑπÔ∏è Nenhum documento encontrado para exclus√£o`);
        }

    } catch (error) {
        console.error("‚ùå Erro ao excluir dados do usu√°rio:", error);
        throw new Error("N√£o foi poss√≠vel excluir todos os dados do usu√°rio. Tente novamente.");
    }
};

/**
 * EXCLUS√ÉO COMPLETA DE USU√ÅRIO - Remove TODOS os dados relacionados
 * Esta fun√ß√£o remove completamente um usu√°rio e todos os seus dados do sistema.
 * Ap√≥s esta exclus√£o, o email poder√° ser reutilizado para criar uma nova conta.
 * 
 * @param userId - O ID do usu√°rio a ser exclu√≠do
 * @param userType - O tipo do usu√°rio (motorista, cliente ou admin)
 * @param isAdminAction - Se true, indica que √© uma exclus√£o feita por admin
 * @returns Promise<{ success: boolean; deletedCount: number; errors: string[] }>
 */
export const deleteUserCompletely = async (
    userId: string, 
    userType: 'motorista' | 'cliente' | 'admin',
    isAdminAction: boolean = false
): Promise<{ success: boolean; deletedCount: number; errors: string[] }> => {
    const errors: string[] = [];
    let deletedCount = 0;
    
    try {
        console.log(`üóëÔ∏è INICIANDO EXCLUS√ÉO COMPLETA DO USU√ÅRIO ${userId} (${userType})`);
        console.log(`üìã Tipo de exclus√£o: ${isAdminAction ? 'ADMIN' : 'AUTO-EXCLUS√ÉO'}`);
        
        // Lista de todas as cole√ß√µes que podem conter dados do usu√°rio
        const collectionsToCheck = [
            { name: 'users', field: '__name__', value: userId },
            { name: 'transactions', field: 'userId', value: userId },
            { name: 'appointments', field: 'userId', value: userId },
            { name: 'workShifts', field: 'userId', value: userId },
            { name: 'vehicles', field: 'userId', value: userId },
            { name: 'notifications', field: 'userId', value: userId },
            { name: 'notificationSettings', field: 'userId', value: userId },
            { name: 'subscriptions', field: 'userId', value: userId },
            { name: 'deliveries', field: 'userId', value: userId },
            { name: 'deliveries', field: 'clientId', value: userId },
            { name: 'deliveries', field: 'driverId', value: userId },
            { name: 'transactions', field: 'clientId', value: userId },
            { name: 'transactions', field: 'driverId', value: userId },
            { name: 'transactions', field: 'assignedDriverId', value: userId }
        ];

        // Processar exclus√µes em lotes para evitar limites do Firestore
        const batchSize = 500; // Limite do Firestore
        let currentBatch = writeBatch(db);
        let currentBatchCount = 0;

        for (const collectionInfo of collectionsToCheck) {
            try {
                console.log(`üîç Verificando cole√ß√£o: ${collectionInfo.name} (campo: ${collectionInfo.field})`);
                
                const q = query(
                    collection(db, collectionInfo.name), 
                    where(collectionInfo.field, "==", collectionInfo.value)
                );
                const snapshot = await getDocs(q);
                
                if (snapshot.size > 0) {
                    console.log(`üìÑ Encontrados ${snapshot.size} documentos em ${collectionInfo.name}`);
                    
                    for (const docSnapshot of snapshot.docs) {
                        // Se o lote atual est√° cheio, executar e criar novo
                        if (currentBatchCount >= batchSize) {
                            try {
                                await currentBatch.commit();
                                console.log(`‚úÖ Lote executado: ${currentBatchCount} documentos exclu√≠dos`);
                                deletedCount += currentBatchCount;
                                currentBatchCount = 0;
                                currentBatch = writeBatch(db);
                            } catch (error) {
                                console.error(`‚ùå Erro ao executar lote:`, error);
                                errors.push(`Erro ao executar lote de exclus√£o: ${error}`);
                            }
                        }
                        
                        currentBatch.delete(docSnapshot.ref);
                        currentBatchCount++;
                    }
                }
            } catch (error) {
                console.warn(`‚ö†Ô∏è Erro ao processar cole√ß√£o ${collectionInfo.name}:`, error);
                errors.push(`Erro na cole√ß√£o ${collectionInfo.name}: ${error}`);
            }
        }

        // Executar o √∫ltimo lote se houver documentos
        if (currentBatchCount > 0) {
            try {
                await currentBatch.commit();
                console.log(`‚úÖ Lote final executado: ${currentBatchCount} documentos exclu√≠dos`);
                deletedCount += currentBatchCount;
            } catch (error) {
                console.error(`‚ùå Erro ao executar lote final:`, error);
                errors.push(`Erro ao executar lote final: ${error}`);
            }
        }

        // Log final da exclus√£o
        console.log(`üéØ EXCLUS√ÉO COMPLETA FINALIZADA:`);
        console.log(`üìä Total de documentos exclu√≠dos: ${deletedCount}`);
        console.log(`‚ö†Ô∏è Erros encontrados: ${errors.length}`);
        
        if (errors.length > 0) {
            console.log(`‚ùå Lista de erros:`, errors);
        }

        return {
            success: errors.length === 0,
            deletedCount,
            errors
        };

    } catch (error) {
        console.error("‚ùå ERRO CR√çTICO na exclus√£o completa:", error);
        errors.push(`Erro cr√≠tico: ${error}`);
        
        return {
            success: false,
            deletedCount,
            errors
        };
    }
};
